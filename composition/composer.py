#imports
from threading import activeCount
from progression import Progression
from chord import Chord

class Composer:
    
    #init function
    def __init__(self,pitches, rules):
        self.pitches=pitches
        self.rules = rules # a list of rule 
        self.progressions = [] # holds instances of progressions

    #generate chord progression function
    def makeChordProgression(self):        
        pitchIdx = 0
        activeProgressions = []
        while pitchIdx < len(self.pitches):
            nextProgressions = []

            #GET POSSIBLE CHORDS AND ADD THEM TO THE ACTIVE PROGRESSIONS
            if len(activeProgressions) == 0:
                for rule in self.rules:
                    possibleChords = rule.getPossibleChords(
                        pitchIdx=pitchIdx,
                        pitch=self.pitches[pitchIdx],
                        prevChord=None
                    )
                    if (possibleChords != None):
                        for chord in possibleChords:
                            nextProgressions.append(Progression([chord]))
            else:
                for progression in activeProgressions:
                    for rule in self.rules:
                        possibleChords = rule.getPossibleChords(
                            pitchIdx=pitchIdx,
                            pitch=self.pitches[pitchIdx],
                            progression=progression,
                            prevChord=progression.chords[len(progression.chords)-1]
                        )
                        if (possibleChords != None):
                            for chord in possibleChords:
                                nextProgressions.append(progression.appendChord(chord))


            #DELETING PROGRESSIONS THAT DON'T WORK
            for progression in nextProgressions:
                chordWorks = rule.checkProgression(
                    rules = self.rules,
                    pitchIdx=pitchIdx,
                    pitch=self.pitches[pitchIdx],
                    prevChord=progression.chords[len(progression.chords)-2],
                    newChord=progression.chords[len(progression.chords)-1],
                    progression=progression
                )
                if (chordWorks):
                    activeProgressions.append(progression)

            pitchIdx += 1

            #REMOVING OLD PROGRESSIONS 
            idx = 0
            while (idx < len(activeProgressions) and (activeProgressions[idx].length()<pitchIdx)):
                idx+=1
            activeProgressions = activeProgressions[idx:]
        self.progressions = activeProgressions #CHANGE THIS LATER ADDED RN TO SEE RESULTS
        return self.progressions



    #function to show the current chord progression generated by the composer to the user (mainly for testing purposes)
    def printProgressions(self):
        for progression in self.progressions:
            print()
            print()
            print("NEXT PROGRESSION...")
            for chord in progression.chords:
                print(chord.stack,end=", ")
        print()
        print()
            


    #function to output the chord progression chosen by the user
    def outputChords(self,fileFormat):
        pass
    

   


#testing
# obj = composer(["A","B","C","D","E","F"])
# obj.makeChordProgression()